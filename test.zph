(*{(R ~ transitive) (X R Y) (Y R Z)} ~ conjunction) => (X R Z)
> ~ transitive

6 > 5
5 > 4
4 < 5

g .. h
h .. i

atom_A => atom_B
atom_C <= atom_D
(A <=> B) is_type equivalence

special_atoms list_contains < <= => >= < > >

"solar system" "is part of" "milky way"
(earth "is part of" "solar system") is_truth true

seq_compact is_defined_as <123>
seq_spaced is_defined_as < seqItem1 seqItem2 seqItem3 >

A in <123>
B in < 1 2 3 >

nested_set_in_seq holds < {seqElem1 seqElem2} {seqElem3 seqElem4} >
nested_seq_in_set holds { <setElem1 setElem2> <setElem3 setElem4> }

container_test stores <(tim ancestor tom) just_a_new_node (tom ancestor paul) ((*{(X ancestor Y) (Y ancestor Z)} ~ conjunction) => (X ancestor Z))>

mixed_container content < (myCond => myDeduct) (myDeduct2 <= myCond2) { setElem5 setElem6 } "literal string" >

_Variable with_underscore _V

quoted_sequence ~ < "a" "b" "c" >

deep_nesting ~ ( Level1 ( Level2 ( Level3 predicate "Level3Object" ) Level2Object) Level1Object)

set_logic ~ { (myItem1 IsA myItem2) (myItem2 IsA myItem3) }

(*tim ~ human) ~ male

tim _predicate _object

# nested unification, test 1
((A + B) = C) => (test A B)
(4 + 5) = 9

# nested unification, test 2
(subj pred (obj is (subj2 A (b test C)))) => (success A C)
subj pred (obj is (subj2 a_val (b test c_val)))

# contradiction test
(*{(A instanceof B) (a subclassof B)} ~ conjunction) => !
gene instanceof geneclass
gene subclassof geneclass

# complex rule
(*{ ((A + B) = C) (B followed-by D) (C followed-by E) } ~ conjunction) => ((A + D) = E)

# numbers
(A followed-by B) => ((<1> + A) = B)
<0> followed-by <1>
